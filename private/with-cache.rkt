#lang racket/base

;; lightweight, filesystem-based caching

(provide
  *use-cache?*
  ;; (Parameterof Boolean)
  ;; When #f, do not read or save caches, ever.

  *with-cache-fasl?*
  ;; (Parameterof Boolean)
  ;; When #t, store cachefiles in fasl format.
  ;; When #f, directly read/write the values.

  *current-cache-directory*
  ;; (Parameterof Path-String)
  ;; Default directory to save caches in.
  ;; Used as a prefix to `cache-file`

  *current-cache-keys*
  ;; (Parameterof (U #f (Listof (Parameterof Any))))
  ;; List of keys to query when reading/writing the cache

  cachefile
  ;; Prefix the path string with the current value of `*CACHE-DIRECTORY*`

  with-cache
  ;; (->* [Path-String (-> A)] [#:read (-> B A) #:write (-> A B)] A)
  ;; (with-cache path thunk #:read r #:write w)
  ;; Checks `path` for a value `r` can interpret; if so returns the interpreted value.
  ;; Else runs `thunk` and writes the result to `path` using `w`.
  ;; (Future calls to `with-cache` will likely retrieve this stored value.)

  parent-directory-exists?

)

(require
  (only-in racket/file file->value delete-directory/files)
  (only-in racket/path path-only)
  (only-in racket/date date-display-format current-date date->string)
  (only-in racket/serialize serialize deserialize)
  (only-in racket/port open-output-nowhere)
  racket/fasl
)

(date-display-format 'iso-8601)

;; =============================================================================

(define *use-cache?* (make-parameter #t))
(define *with-cache-fasl?* (make-parameter #t))
(define *current-cache-directory* (make-parameter "./compiled"))
(define *current-cache-keys* (make-parameter #f))

(define (parent-directory-exists? ps)
  (and (path-string? ps)
       (let ([dir (path-only ps)])
         (or (not dir) (directory-exists? dir)))))

(define (cachefile ps)
  (build-path (*current-cache-directory*) ps))

(define ((cache-read-error cachefile) exn) ; (-> Path-String (-> Exception #f))
  (log-with-cache-error "Failed to read cachefile '~a', got exception:~n~a~n"
                        cachefile
                        (exn-message exn))
  #f)

(define ((cache-write-error cachefile) exn) ; (-> Path-String (-> Exception Void)
  (log-with-cache-error "Failed to write cachefile '~a', got exception:~n~a~n"
                        cachefile
                        (exn-message exn))
  (with-handlers ([exn:fail:filesystem (λ () (void))])
    (delete-directory/files cachefile #:must-exist? #f)))

(define-logger with-cache)
(define (with-cache cache-file thunk #:read [read-proc deserialize] #:write [write-proc serialize])
  (let ([read-proc (read/current-keys read-proc)]
        [write-proc (write/current-keys write-proc)]
        [fasl? (*with-cache-fasl?*)]
        [use? (*use-cache?*)])
    (or (and use?
             (file-exists? cache-file)
             (with-handlers ([exn:fail? (cache-read-error cache-file)])
               (log-with-cache-info "reading cachefile '~a'...~n" cache-file)
               (begin0
                 (read-proc (call-with-input-file cache-file (if fasl? fasl->s-exp read)))
                 (log-with-cache-info "successfully read cachefile '~a'~n" cache-file))))
        (let ([r (thunk)])
          (when use?
            (log-with-cache-info "writing cachefile '~a'~n" cache-file)
            (with-handlers ([exn:fail? (cache-write-error cachefile)])
              (with-output-to-file cache-file #:exists 'replace
                (λ ()
                  (displayln
                   (string-append
                    ";; This file was generated by the `with-cache` library on "
                    (date->string (current-date))))
                  (if fasl?
                      (s-exp->fasl (write-proc r) (current-output-port))
                      (writeln (write-proc r)))
                  (log-with-cache-info "successfully wrote to cachefile '~a'~n" cache-file)))))
          r))))

(define (read/current-keys read-proc)
  (define keys (*current-cache-keys*))
  (if keys
    (λ (v)
      (and (pair? v)
           (list? (car v))
           (equal? (car v) (ref* keys))
           (read-proc (cdr v))))
    read-proc))

(define (write/current-keys write-proc)
  (define keys (*current-cache-keys*))
  (if keys
    (λ (v)
      (cons (ref* keys) (write-proc v)))
    write-proc))

(define (ref* param*)
  (for/list ([param (in-list param*)])
    (param)))

;; =============================================================================

(module+ test
  (require rackunit)

  (let ([x (gensym 'x)]
        [y (gensym 'y)])
    (parameterize ([*current-cache-directory* (format "./~a" x)])
      (check-equal?
        (cachefile (symbol->string y))
        (string->path (format "./~a/~a" x y)))))

  (check-equal?
   ((cache-read-error "tmp") (exn "Not really a problem" (current-continuation-marks)))
   #f)

  (let ([x (gensym 'x)]
        [y (gensym 'y)])
    (check-equal?
      ((write/current-keys (λ (_) x)) y)
      x)
    (check-equal?
      ((read/current-keys (λ (_) y)) x)
      y))

  (check-equal?
    (ref* (list *use-cache?* *use-cache?*))
    '(#t #t))

)
